const Promise = require(`bluebird`)

const {onCreateNode} = require(`../gatsby-node`)
describe(`Process docutil nodes correctly`, () => {
    const node = {
        name: `nodeName`,
        id: `whatever`,
        parent: null,
        children: [],
        internal: {
            contentDigest: `whatever`,
            mediaType: `application/xml`,
            name: `test`,
        },
    }

    // Make some fake functions its expecting.
    node.content = `<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="/home/cristian/docs/docs/source/vgs-collect/masking.rst">
    <section ids="masking-and-formatting" names="masking\\ and\\ formatting">
        <title>Masking and formatting</title>
        <image alt="'VGS Collect.js masked input'" candidates="{'*': 'vgs-collect/../../_static/img/masking-collect.gif'}" uri="vgs-collect/../../_static/img/masking-collect.gif"></image>
        <section ids="create-a-custom-mask" names="create\\ a\\ custom\\ mask">
            <title>Create a custom mask</title>
            <paragraph>Input mask refers to a string expression, defined by a developer, that constrains user input.
                This method is available for those type of the fields: <literal>text</literal>, <literal>textarea</literal>, <literal>password</literal>, <literal>zip-code</literal>.</paragraph>
            <literal_block highlight_args="{}" language="none" linenos="False" xml:space="preserve">field.mask(mask, maskChar, formatChar);</literal_block>
            <line_block>
                <line><literal>mask</literal> <emphasis>String</emphasis></line>
                <line_block>
                    <line>mask string. Default format characters are: <literal>9: [0-9]</literal>, <literal>a: [A-Za-z]</literal>, <literal>*: [A-Za-z0-9]</literal>.</line>
                </line_block>
            </line_block>
            <line_block>
                <line><literal>maskChar</literal> <emphasis>String</emphasis></line>
                <line_block>
                    <line>character to cover unfilled parts of the mask. By default - <literal>null</literal>.</line>
                </line_block>
            </line_block>
            <line_block>
                <line><literal>formatChar</literal> <emphasis>Object</emphasis></line>
                <line_block>
                    <line>defines format characters with characters as keys and corresponding RegExp strings as a value.</line>
                </line_block>
            </line_block>
            <paragraph>Example:</paragraph>
            <literal_block highlight_args="{}" language="javascript" linenos="False" xml:space="preserve">f.field("#ssn .field-space", {}).mask('999-99-9999', '*');

f.field("#random-mask .field-space", {}).mask('XXXXX', null, {'X': '[0-9]'});</literal_block>
        </section>
        <section ids="define-string-replace-pattern" names="define\\ string\\ replace\\ pattern">
            <title>Define string replace pattern</title>
            <paragraph>Method returns a new string with some or all matches of a pattern replaced by a replacement.
                This method is available for those type of the fields: <literal>text</literal>, <literal>textarea</literal>, <literal>password</literal>, <literal>zip-code</literal>.</paragraph>
            <literal_block highlight_args="{}" language="none" linenos="False" xml:space="preserve">field.replacePattern(regExpString, newSubStr);</literal_block>
            <line_block>
                <line><literal>regExpString</literal> <emphasis>String</emphasis></line>
                <line_block>
                    <line>a RegExpÂ object or literal. The match or matches are replaced with <title_reference>newSubStr</title_reference>.</line>
                </line_block>
            </line_block>
            <line_block>
                <line><literal>newSubStr</literal> <emphasis>String</emphasis></line>
                <line_block>
                    <line>the string that replaces the substring specified by the regExp. By default - empty string.</line>
                </line_block>
            </line_block>
            <paragraph>Example:</paragraph>
            <literal_block highlight_args="{}" language="javascript" linenos="False" xml:space="preserve">f.field("#letters-only .field-space", {}).replacePattern('/[^a-zA-Z\\\\s]+/g');

f.field("#numeric-only .field-space", {}).replacePattern('/[^\\\\d]+/g');</literal_block>
        </section>
        <section ids="control-expiration-date-year-length" names="control\\ expiration\\ date\\ year\\ length">
            <title>Control expiration date year length</title>
            <paragraph>By default expiration date format is - <literal>MM/YYYY</literal>. If you want to change the length of the year
                from 4 to 2 digits, just simply set <literal>yearLength</literal> param to <literal>2</literal>.</paragraph>
            <paragraph>Example:</paragraph>
            <literal_block highlight_args="{}" language="javascript" linenos="False" xml:space="preserve">f.field("#expiration-date .field-space", { yearLength: 2 });</literal_block>
        </section>
        <section ids="playgrounds" names="playgrounds">
            <title>Playgrounds</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><raw format="html" xml:space="preserve">&lt;a href="https://verygoodsecurity.github.io/vgs-collect-examples/masked-examples.html" target="_blank"&gt;VGS Collect.js masking and formatting examples page&lt;/a&gt;</raw></paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="masking_examples"><raw format="html" xml:space="preserve">&lt;a href="https://verygoodsecurity.github.io/vgs-collect-examples/masked-examples.html" target="_blank"&gt;VGS Collect.js masking and formatting examples page&lt;/a&gt;</raw></substitution_definition>
        </section>
    </section>
</document>`;
    const loadNodeContent = node => Promise.resolve(node.content);

    it(`correctly creates nodes from docutils`, async () => {
        const createNode = jest.fn()
        const createParentChildLink = jest.fn()
        const actions = {createNode, createParentChildLink}
        const createNodeId = jest.fn()
        createNodeId.mockReturnValue(`uuid-from-gatsby`)
        const createContentDigest = jest.fn().mockReturnValue(`contentDigest`)

        await onCreateNode({
            node,
            loadNodeContent,
            actions,
            createNodeId,
            createContentDigest,
        }).then(() => {
            expect(createNode.mock.calls).toMatchSnapshot()
            expect(createParentChildLink.mock.calls).toMatchSnapshot()
            expect(createNode).toHaveBeenCalledTimes(1)
            expect(createParentChildLink).toHaveBeenCalledTimes(1)
        })
    })
})
